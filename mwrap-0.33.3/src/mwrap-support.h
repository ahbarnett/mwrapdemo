/*
 * Auto-generated by stringify
 */

const char* mex_header =
  "/* Code generated by mwrap */\n"
  "/*\n"
  "  Copyright statement for mwrap:\n"
  "\n"
  "  mwrap -- MEX file generation for MATLAB and Octave\n"
  "  Copyright (c) 2007-2008 David Bindel\n"
  "\n"
  "  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
  "  of this software and associated documentation files (the \"Software\"), to deal\n"
  "  in the Software without restriction, including without limitation the rights\n"
  "  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
  "  copies of the Software, and to permit persons to whom the Software is\n"
  "  furnished to do so, subject to the following conditions:\n"
  "\n"
  "  The above copyright notice and this permission notice shall be included in\n"
  "  all copies or substantial portions of the Software.\n"
  "\n"
  "  You may distribute a work that contains part or all of the source code\n"
  "  generated by mwrap under the terms of your choice.\n"
  "\n"
  "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
  "  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
  "  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
  "  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
  "  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
  "  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
  "  THE SOFTWARE.\n"
  "*/\n"
  "\n"
  "#include <mex.h>\n"
  "#include <stdio.h>\n"
  "#include <string.h>\n"
  "\n"
  "\n"
  "#ifndef ulong\n"
  "#  define ulong unsigned long\n"
  "#endif\n"
  "#ifndef uint\n"
  "#  define uint  unsigned int\n"
  "#endif\n"
  "#ifndef uchar\n"
  "#  define uchar unsigned char\n"
  "#endif\n"
  "\n"
  "\n"
  "/*\n"
  " * Support for 32-bit and 64-bit MEX files\n"
  " */\n"
  "#ifndef mwSize\n"
  "#  define mwSize int\n"
  "#endif\n"
  "#ifndef mwIndex\n"
  "#  define mwIndex int\n"
  "#endif\n"
  "#ifndef mwSignedIndex\n"
  "#  define mwSignedIndex int\n"
  "#endif\n"
  "\n"
  "\n"
  "/*\n"
  " * Records for call profile.\n"
  " */\n"
  "int* mexprofrecord_= NULL;\n"
  "\n"
  "\n"
  "/*\n"
  " * Support routines for copying data into and out of the MEX stubs\n"
  " */\n"
  "\n"
  "void* mxWrapGetP(const mxArray* a, const char* fmt, const char** e)\n"
  "{\n"
  "    void* p = 0;\n"
  "    mxArray* ap;\n"
  "    if (mxGetClassID(a) == mxDOUBLE_CLASS && \n"
  "        mxGetM(a)*mxGetN(a) == 1 && *mxGetPr(a) == 0)\n"
  "        return p;\n"
  "    if (mxIsChar(a)) {\n"
  "        char pbuf[128];\n"
  "        mxGetString(a, pbuf, sizeof(pbuf));\n"
  "        sscanf(pbuf, fmt, &p);\n"
  "    } \n"
  "#ifdef R2008OO\n"
  "    else if (ap = mxGetProperty(a, 0, \"mwptr\")) {\n"
  "        return mxWrapGetP(ap, fmt, e);\n"
  "    }\n"
  "#endif\n"
  "    if (p == 0)\n"
  "        *e = \"Invalid pointer\";\n"
  "    return p;\n"
  "}\n"
  "\n"
  "mxArray* mxWrapCreateP(void* p, const char* fmt)\n"
  "{\n"
  "    if (p == 0) {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetPr(z) = 0;\n"
  "        return z;\n"
  "    } else {\n"
  "        char pbuf[128];\n"
  "        sprintf(pbuf, fmt, p);\n"
  "        return mxCreateString(pbuf);\n"
  "    }\n"
  "}\n"
  "\n"
  "mxArray* mxWrapStrncpy(const char* s)\n"
  "{\n"
  "    if (s) {\n"
  "        return mxCreateString(s);\n"
  "    } else {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetPr(z) = 0;\n"
  "        return z;\n"
  "    }\n"
  "}\n"
  "\n"
  "double mxWrapGetScalar(const mxArray* a, const char** e)\n"
  "{\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS || mxGetM(a)*mxGetN(a) != 1) {\n"
  "        *e = \"Invalid scalar argument\";\n"
  "        return 0;\n"
  "    }\n"
  "    return *mxGetPr(a);\n"
  "}\n"
  "\n"
  "char* mxWrapGetString(const mxArray* a, const char** e)\n"
  "{\n"
  "    char* s;\n"
  "    mwSize slen;\n"
  "    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0)) {\n"
  "        *e = \"Invalid string argument\";\n"
  "        return NULL;\n"
  "    }\n"
  "    slen = mxGetM(a)*mxGetN(a) + 1;\n"
  "    s = (char*) mxMalloc(slen);\n"
  "    if (mxGetM(a)*mxGetN(a) == 0)\n"
  "        *s = 0;\n"
  "    else\n"
  "        mxGetString(a, s, slen);\n"
  "    return s;\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayDef(func, T) \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* q; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    q = mxGetPr(a); \\\n"
  "    for (i = 0; i < arraylen; ++i) \\\n"
  "        *p++ = (T) (*q++); \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyDef(func, T) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p = mxGetPr(a); \\\n"
  "    for (i = 0; i < n; ++i) \\\n"
  "        *p++ = *q++; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnDef(func, T) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxREAL); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxREAL); \\\n"
  "        p = mxGetPr(a); \\\n"
  "        for (i = 0; i < m*n; ++i) \\\n"
  "            *p++ = *q++; \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetScalarZDef(func, T, ZT, setz) \\\n"
  "void func(T* z, const mxArray* a) \\\n"
  "{ \\\n"
  "    double* pr = mxGetPr(a); \\\n"
  "    double* pi = mxGetPi(a); \\\n"
  "    setz(z, (ZT) *pr, (pi ? (ZT) *pi : (ZT) 0)); \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayZDef(func, T, ZT, setz) \\\n"
  "T* func(const mxArray* a, const char** e) \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* qr; \\\n"
  "    double* qi; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    qr = mxGetPr(a); \\\n"
  "    qi = mxGetPi(a); \\\n"
  "    for (i = 0; i < arraylen; ++i) { \\\n"
  "        ZT val_qr = *qr++; \\\n"
  "        ZT val_qi = (qi ? (ZT) *qi++ : (ZT) 0); \\\n"
  "        setz(p, val_qr, val_qi); \\\n"
  "        ++p; \\\n"
  "    } \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyZDef(func, T, real, imag) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* pr = mxGetPr(a); \\\n"
  "    double* pi = mxGetPi(a); \\\n"
  "    for (i = 0; i < n; ++i) { \\\n"
  "        *pr++ = real(*q); \\\n"
  "        *pi++ = imag(*q); \\\n"
  "        ++q; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnZDef(func, T, real, imag) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* pr; \\\n"
  "    double* pi; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxCOMPLEX); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxCOMPLEX); \\\n"
  "        pr = mxGetPr(a); \\\n"
  "        pi = mxGetPi(a); \\\n"
  "        for (i = 0; i < m*n; ++i) { \\\n"
  "            *pr++ = real(*q); \\\n"
  "            *pi++ = imag(*q); \\\n"
  "            ++q; \\\n"
  "        } \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n";

